<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>equals和hashCode源码解析 · Codering&#x27;s Knowledge</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="From https://my.oschina.net/pingpangkuangmo/blog/376334"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="equals和hashCode源码解析 · Codering&#x27;s Knowledge"/><meta property="og:type" content="website"/><meta property="og:url" content="https://codering.github.io/knowledge/index.html"/><meta property="og:description" content="From https://my.oschina.net/pingpangkuangmo/blog/376334"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/knowledge/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://codering.github.io/knowledge/blog/atom.xml" title="Codering&#x27;s Knowledge Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://codering.github.io/knowledge/blog/feed.xml" title="Codering&#x27;s Knowledge Blog RSS Feed"/><link rel="stylesheet" href="/css/code-blocks-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-blocks-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/knowledge/css/prism.css"/><link rel="stylesheet" href="/knowledge/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/knowledge/"><img class="logo" src="/knowledge/img/docusaurus.svg" alt="Codering&#x27;s Knowledge"/><h2 class="headerTitleWithLogo">Codering&#x27;s Knowledge</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="/knowledge/docs/nginx_basic_auth" target="_self">Docs</a></li><li class=""><a href="/knowledge/docs/java/juc_object_lock" target="_self">Java Concurrency</a></li><li class=""><a href="/knowledge/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docMainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">equals和hashCode源码解析</h1></header><article><div><span><p>From <a href="https://my.oschina.net/pingpangkuangmo/blog/376334">https://my.oschina.net/pingpangkuangmo/blog/376334</a></p>
<p>equals和hashCode网上也有很多的资料。这里只是记录下我目前的理解与认识。
大家会经常听到这样的话，当你重写equals方法时，尽量要重写hashCode方法，有些人却并不知道为什么要这样，待会就会给出源码说明这个原因。</p>
<h2><a class="anchor" aria-hidden="true" id="关注点"></a><a href="#关注点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关注点</h2>
<p>首先来介绍下Object的equals和hashCode方法。如下：</p>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);
}
</code></pre>
<p>这里挺简单的，equals(obj)默认比较的是内存地址，hashCode()方法默认是native方法，看下它的文档说明：</p>
<pre><code class="hljs css language-java"><span class="hljs-comment">/**
* 关注点1
     * Returns a hash code value for the object. This method is
     * supported for the benefit of hash tables such as those provided by
     * {<span class="hljs-doctag">@link</span> java.util.HashMap}.
     * &lt;p&gt;
     * The general contract of {<span class="hljs-doctag">@code</span> hashCode} is:
     * &lt;ul&gt;
     * &lt;li&gt;Whenever it is invoked on the same object more than once during
     *     an execution of a Java application, the {<span class="hljs-doctag">@code</span> hashCode} method
     *     must consistently return the same integer, provided no information
     *     used in {<span class="hljs-doctag">@code</span> equals} comparisons on the object is modified.
     *     This integer need not remain consistent from one execution of an
     *     application to another execution of the same application.
* 关注点2
     * &lt;li&gt;If two objects are equal according to the {<span class="hljs-doctag">@code</span> equals(Object)}
     *     method, then calling the {<span class="hljs-doctag">@code</span> hashCode} method on each of
     *     the two objects must produce the same integer result.
     * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal
     *     according to the {<span class="hljs-doctag">@link</span> java.lang.Object#equals(java.lang.Object)}
     *     method, then calling the {<span class="hljs-doctag">@code</span> hashCode} method on each of the
     *     two objects must produce distinct integer results.  However, the
     *     programmer should be aware that producing distinct integer results
     *     for unequal objects may improve the performance of hash tables.
     * &lt;/ul&gt;
     * &lt;p&gt;
* 关注点3
     * As much as is reasonably practical, the hashCode method defined by
     * class {<span class="hljs-doctag">@code</span> Object} does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java&lt;font size="-2"&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; programming language.)
     *
     * <span class="hljs-doctag">@return</span>  a hash code value for this object.
     * <span class="hljs-doctag">@see</span>     java.lang.Object#equals(java.lang.Object)
     * <span class="hljs-doctag">@see</span>     java.lang.System#identityHashCode
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;
</code></pre>
<p>这里有三个关注点。</p>
<p>关注点1：主要是说这个hashCode方法对哪些类是有用的，并不是任何情况下都要使用这个方法（此时是根本没有必要来复写此方法），而是当你涉及到像HashMap、HashSet(他们的内部实现中使用到了hashCode方法)等与hash有关的一些类时，才会使用到hashCode方法。</p>
<p>关注点2：推荐按照这样的原则来设计，即当equals(object)相同时，hashCode（）的返回值也要尽量相同，当equals(object)不相同时，hashCode（）的返回没有特别的要求，但是也是尽量不相同以获取好的性能。</p>
<p>关注点3：默认的hashCode实现一般是内存地址对应的数字，所以不同的对象，hashCode（）的返回值是不一样的。</p>
<h2><a class="anchor" aria-hidden="true" id="java世界里的相同"></a><a href="#java世界里的相同" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>java世界里的相同</h2>
<p>如Person类，含有name和age属性：</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{

    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> age;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.age = age;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>{
        <span class="hljs-keyword">if</span>(!(obj <span class="hljs-keyword">instanceof</span> Person)){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
        Person tmp=(Person)obj;
        <span class="hljs-keyword">return</span> name.equals(tmp.getName()) &amp;&amp; age==tmp.getAge();
    }
}
</code></pre>
<p>我们认为当name和age值都相同时就是一个相同的person，所以我们可以重写equals方法如上所述，这样我们就可以调用perosn1.equals(person2)来判断他们是否相同。然而这样就完了吗？如果你不涉及其他有关hash方面的内容，这样的确可以满足你的需求了，也就是说这样做仅仅是针对部分情况是可以的，并没有针对全部情况，如若使用HashMap、HashSet等还想实现person1和person2相同，仅仅重写equals方法肯定是不够的，必须要重写hashCode方法。</p>
<h2><a class="anchor" aria-hidden="true" id="为什么会有hash类型的map"></a><a href="#为什么会有hash类型的map" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么会有Hash类型的Map？</h2>
<p>简单理解：Map本身是存放key和value信息的地方，若想获取某个key1对应的value，即map.get(key1)，常规思维就是拿key1和所有的key一个一个去比较，若相同，则返回对应的value。假如有10000个key，要比较10000次吗？这样的效率难道不是很低下的吗？所以要改进，假如我们对key1进行某种运算直接能得到对应value的存储位置，来直接获取到value，这样不是最爽的吗？不再和其他key进行比较了，而是得到位置，直接获取对应的value。这就是HashMap等的基本原理，同时hashCode方法在得到位置信息上发挥着巨大的作用。</p>
<p>接下来HashMap的源码分析这一具体过程：</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = {};
<span class="hljs-keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;
</code></pre>
<p>HashMap内部是由Entry&lt;K,V&gt;类型的数组table来存储数据的。来看下Entry&lt;K,V&gt;的代码：</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>{
    <span class="hljs-keyword">final</span> K key;
    V value;
    Entry&lt;K,V&gt; next;
    <span class="hljs-keyword">int</span> hash;

    <span class="hljs-comment">/**
      * Creates new entry.
      */</span>
    Entry(<span class="hljs-keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }
    <span class="hljs-comment">//略</span>
}
</code></pre>
<p>Entry&lt;K,V&gt;有四个重要的属性，是一对key和value的结合，同时包含下一个Entry&lt;K,V&gt;，就像链表一样，最后一个就是哈希值h（这个哈希值就是key的hashCode方法的返回值经过hash运算得到的值）。
所以我们可以画出HashMap的存储结构：</p>
<p><img src="/knowledge/img/doc/java_hashmap.png" alt="HashMap"></p>
<p>图中的每一个方格就表示一个Entry&lt;K,V&gt;对象，其中的横向则构成一个Entry&lt;K,V&gt;[] table数组，而竖向则是由Entry&lt;K,V&gt;的next属性形成的链表。</p>
<p>假入我们想找编号为2的value，如果我们能直接找到它所在数组中的索引便可以快速找到它，假如我们想找编号为73的value，如果我们能直接找到编号7然后再继续沿着链表寻找，便可以快速找到它。</p>
<h3><a class="anchor" aria-hidden="true" id="hashmap-put分析"></a><a href="#hashmap-put分析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HashMap put分析</h3>
<p>首先看下它HashMap是如何来添加的，即 put(K key, V value)方法：</p>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>{
    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">return</span> putForNullKey(value);
    <span class="hljs-keyword">int</span> hash = hash(key);
    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);
    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) {
        Object k;
        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">return</span> oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre>
<p>现在先不管HashMap扩容的事情，我们重点关注它的存的过程，首先就是计算key的hash值，这个hash计算的过程便用到了key对象的hashCode方法，如下：</p>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object k)</span> </span>{
    <span class="hljs-keyword">int</span> h = hashSeed;
    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) {
        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span>
    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span>
    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span>
    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);
    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);
}
</code></pre>
<p>先不用看懂这个方法是怎么计算的，它的内容就是对key的hashCode方法返回值进行一系列的运算得到一个最终的值，这个值就是hash值，就是上文所说的Entry&lt;K,V&gt;中的h属性的值。</p>
<p>得到这个hash值后，紧接着执行了int i = indexFor(hash, table.length)；就是找到这个hash值在table数组中的索引值，具体方法indexFor(hash, table.length)为：</p>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>{
    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);
}
</code></pre>
<p>就是拿刚才生成的hash值和（table数组的长度减一）进行了相&amp;操作，可以看到我们得到的hash值是一个很大很大的数字，和length-1相&amp;之后的值，必然是在0到length-1之内，即在table数组的范围之内。得到的这个索引之后，接下来针对这个索引值对应的链表便进行放入或者替换操作。遍历这个链表，拿要放进来的key和这个链表上的每一对象的key进行下对比，看是否一致，若一致则进行替换操作，若都不一致则进行新的插入操作。</p>
<p>判断是否一致的条件是：<code>e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))</code>，一定要牢牢记住这个条件。</p>
<p>必须满足的条件1：hash值一样，hash值的来历就是根据key的hashCode再进行一个复杂的运算，当两个key的hashCode一致的时候，计算出来的hash也是必然一样的。</p>
<p>必须满足的条件2：两个key的引用一样或者equals相同。</p>
<p>综上所述，HashMap对于key的重复性判断是基于两个内容的判断，一个就是hash值是否一样（会演变成key的hashCode是否一样），另一个就是equals方法是否一样（引用一样则肯定一样）。它依据的是两个条件，所以对于上文的Person类，若想在HashMap中以person对象作为key，要满足person1对象和person2对象一样,则我们必须要重写equals方法和hashCode方法。若没有重写hashCode方法，则使用系统默认的本地hashCode方法，不同的对象的hashCode是不一样的，所以HashMap在判断时就会认为person1和person2是不一样，造成了我们事与愿违的结果。</p>
<h3><a class="anchor" aria-hidden="true" id="为什么要判断key的hash是否一致"></a><a href="#为什么要判断key的hash是否一致" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么要判断key的hash是否一致</h3>
<p>HashMap为什么要多引入key的hash是否一致的判断条件呢？为什么不仅仅判断equals方法是否一样？</p>
<p>我认为原因如下:</p>
<p>好处1：当这个table数组特别大的时候，如长度为10000，根据hash&amp;length-1这个计算的索引值，便很快的定位某一个链表下，过滤了很大一批数据，不需要一个一个遍历。仅仅依靠equals是无法实现这样的快速过滤的。</p>
<p>好处2：不同的hash值得出的索引位置很可能是一样的，所以在这个链表下仍要进一步判断，此时就需要一个一个进行遍历。Entry&lt;K,V&gt;对象中hash值是已经保存的数据，新的key的hash也已经计算出来，所以在遍历对比的过程中判断hash值是否一致是相当快的，如果不一致，则认为不相同继续下一个判断，就不会调用费时的equals方法。假如这个链表的数据也特别多，判断过程也是相当快的。也就是说，判断hash是否一致加快了在链表上的遍历的速度，减少了相对费时的equals调用次数。</p>
<p>综上所述，<font color="red">为了实现HashMap的上述高效的存储操作，引入了hash这个重要的东西。同时带给我们的附加操作就是要满足key一致除了equals返回true外，还必须让hashCode一样</font>。所以我们重写equals方法的时候尽量的重写hashCode方法，当用到HashMap或者HashSet等时必须要重写hashCode方法。</p>
<p><font color="red">hashCode的重写的原则：当equals方法返回true，则两个对象的hashCode必须一样。</font></p>
<p>如String、Integer等类都重写了equals方法和hashCode方法，都是遵循上述原则。所以我们在重写hashCode时也要遵循上述原则。</p>
<h3><a class="anchor" aria-hidden="true" id="hashmap-get分析"></a><a href="#hashmap-get分析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HashMap get分析</h3>
<p>接下来看下get(Object key)源代码的具体寻找过程：</p>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>{
    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">return</span> getForNullKey();
    Entry&lt;K,V&gt; entry = getEntry(key);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> == entry ? <span class="hljs-keyword">null</span> : entry.getValue();
}
</code></pre>
<p>就是找到对应key的Entry&lt;K,V&gt;对象，有了这个对象我们便可以获取到value。继续看下是如何来找到key对应的Entry&lt;K,V&gt;对象的：</p>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title">getEntry</span><span class="hljs-params">(Object key)</span> </span>{
    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-keyword">int</span> hash = (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : hash(key);
    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
          e != <span class="hljs-keyword">null</span>;
          e = e.next) {
        Object k;
        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
            <span class="hljs-keyword">return</span> e;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre>
<p>看到这里就会明白了这个过程，和上面put的过程类似的。</p>
<h3><a class="anchor" aria-hidden="true" id="hash冲突"></a><a href="#hash冲突" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>hash冲突</h3>
<p><font color="red">hash&amp;length-1结果相同我们称为冲突</font></p>
<p>同时要思考什么样的情况下，get（key）过程是最快的？当然是hash&amp;length-1的结果所在的数组索引下只有一个对象，还没有其他对象插入进来。也就是当所有的数据均匀分布在table上，而不是集中在table某个索引对应的连表上的时候此时get操作的效率是相当高的，为了达到这一个操作，就是要满足hash&amp;length-1要尽可能的不同，减少冲突。</p>
<p>首先看length-1：它的原因是因为要限制在table数组内，同时还有一个重要的作用就是减少冲突。首先要知道length的长度是2的幂级数，这个是HashMap来保证的，下一篇文章再说HashMap的大小及扩容。假如length为7,3&amp;(7-1) 即二进制的11&amp;110等于10,2&amp;(7-1),即二进制的10&amp;110即10，这就是说2和3这两个值不一样，却造成了一样的索引值，即产生了冲突，当length=8时，11&amp;111为11,10&amp;111为10所以避免了冲突。所以当length-1的二进制为全1时，会起到避免冲突的作用。</p>
<p>接着看hash值，hash值是由key的hashCode经过hash运算得到的，为了让hash&amp;length-1的结果尽量不产生冲突，hash的值也要尽量均匀，这就对hash算法提出了很高的要求，一个好的hash算法，会让不同的hashCode计算出来的hash值更加均匀分布。hash算法不在本文的范围之内，感兴趣的可以去研究。</p>
<h3><a class="anchor" aria-hidden="true" id="hashset的原理"></a><a href="#hashset的原理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HashSet的原理</h3>
<p>接下来顺便看看HashSet的原理：</p>
<p>Set与List相比是无序的，不允许元素重复。元素重复的依据和HashMap对key的要求是一样的。即所存元素的hash值一样并且equals相同才是一样的元素。看下代码：</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();
</code></pre>
<p>看到了没有，HashSet内部是有一个HashMap的，这个key就是HashSet的元素，而value始终是一个固定的值PRESENT。
看下HashSet的add方法：</p>
<pre><code class="hljs css language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>{
    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;
}
</code></pre>
<p>看到没有，HashSet就是依托HashMap中的key不能重复来实现HashSet中自身的元素不能重复的。</p>
</span></div></article></div><div class="docs-prevnext"></div><p style="font-size:12px;text-align:right"><strong>Last updated: </strong>2018-8-10 10:33:32</p></div></div><nav class="onPageNav docOnPageNav"><ul class="toc-headings"><li><a href="#关注点">关注点</a></li><li><a href="#java世界里的相同">java世界里的相同</a></li><li><a href="#为什么会有hash类型的map">为什么会有Hash类型的Map？</a><ul class="toc-headings"><li><a href="#hashmap-put分析">HashMap put分析</a></li><li><a href="#为什么要判断key的hash是否一致">为什么要判断key的hash是否一致</a></li><li><a href="#hashmap-get分析">HashMap get分析</a></li><li><a href="#hash冲突">hash冲突</a></li><li><a href="#hashset的原理">HashSet的原理</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer" style="display:none"></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '35661468ccd73ff72b970d01662bde7b',
                indexName: 'codering',
                inputSelector: '#search_input_react'
              });
            </script></body></html>